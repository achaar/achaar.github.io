{
  "id": "fare-calendar-system",
  "slug": "fare-calendar-system",
  "highlightedLanguages": [],
  "source": "---\ntags:\n  - project\n---\n# Smart Fare calendar system\n\nDesign a simple fare calendar system in order to cluster different price range in respective air route to get a better understanding to price variation throughout the year. Instead of having just minimum, maximum and median airfare to represent three classes of fare distribution in fare calendar,\nwe can design a smart airfare categorization using clustering algorithms.\n\n## Clustering algorithm\n\nCluster analysis or clustering is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some sense or another) to each other than to those in other groups (clusters). Cluster analysis itself is not one specific algorithm, but the general task to be solved. It can be achieved by various algorithms that differ significantly in their notion of what constitutes a cluster and how to efficiently find them. Popular notions of clusters include groups with small distances among the cluster members, dense areas of the data space, intervals or particular statistical distributions. Clustering can therefore be formulated as a multi-objective optimization problem.\n\n## Clustering in fare calendar system\n\nWe can devise fare calendar system as a clustering problem in which fares can be categorized via automatic classification into clusters. Similarity amongst fares can be viewed as the minimal difference in airfare within the cluster. We can also determine optimal number of cluster which can represent fare variation in most appropriate details.\n\n### K-means for clustering\n\n[k-means](https://www.wikiwand.com/en/K-means_clustering) clustering aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster. Mathematically:\n\nGiven a set of observations ($x_1$, $x_2$, …, $x_n$), where each observation is a d-dimensional real vector, k-means clustering aims to partition the n observations into $k$ ($\\leq n$) sets $S$ = {$S_1$, $S_2$, …, $S_k$} so as to minimize the within-cluster sum of squares (WCSS) (i.e. variance). Formally, the objective is to find:\n\n<!--Mathematical equation in markdown take from wikipedia-->\n<!--Office work-->\n\n\n<!--Write about k-means-->\n\n<!--Determing k automatically-->\nIn Kmeans $k$ or the number of clusters can be taken as a hyperparameter. In order to determine $k$ automatically, either we can perform cross-validation or we can use other algorithms like silhouette analysis. Silhouette refers to a method of interpretation and validation of consistency within clusters of data.\n\nThe silhouette value is a measure of how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The silhouette ranges from -1 to 1, where a high value indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters. If most objects have a high value, then the clustering configuration is appropriate. If many points have a low or negative value, then the clustering configuration may have too many or too few clusters.\n\n## Features in consideration, implementation and EDA involved\n\nTo construct fare calendar system as a Kmeans problem, we constructed features such as fare and date of journey for every arrival station, departure station and date of search(Since dynamic pricing of airline varies on these parameters heavily). We then dynamically constructed clusters for these fares. Using the above trained model we then, predicted every fare for different date of journey. This helps our fare calendar to give a better understanding of fare displayed (low, medium or high) for the searched route.\n\n<!--Add some EDA and clustered prices with seperate bandwidth and use matplotlib-->\n\n<!--Scala job and Mlib usage-->\n\nData that needs to be taken into consideration is massive, moreover the algorithm should be run daily so that we can avoid stale clusters. We can write a spark job using [MLib library](https://spark.apache.org/docs/1.2.0/mllib-clustering.html).\n",
  "rendered": "<h1>Smart Fare calendar system</h1>\n<p>Design a simple fare calendar system in order to cluster different price range in respective air route to get a better understanding to price variation throughout the year. Instead of having just minimum, maximum and median airfare to represent three classes of fare distribution in fare calendar,<br>\nwe can design a smart airfare categorization using clustering algorithms.</p>\n<h2>Clustering algorithm</h2>\n<p>Cluster analysis or clustering is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some sense or another) to each other than to those in other groups (clusters). Cluster analysis itself is not one specific algorithm, but the general task to be solved. It can be achieved by various algorithms that differ significantly in their notion of what constitutes a cluster and how to efficiently find them. Popular notions of clusters include groups with small distances among the cluster members, dense areas of the data space, intervals or particular statistical distributions. Clustering can therefore be formulated as a multi-objective optimization problem.</p>\n<h2>Clustering in fare calendar system</h2>\n<p>We can devise fare calendar system as a clustering problem in which fares can be categorized via automatic classification into clusters. Similarity amongst fares can be viewed as the minimal difference in airfare within the cluster. We can also determine optimal number of cluster which can represent fare variation in most appropriate details.</p>\n<h3>K-means for clustering</h3>\n<p><a href=\"https://www.wikiwand.com/en/K-means_clustering\">k-means</a> clustering aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster. Mathematically:</p>\n<p>Given a set of observations (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">x_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">x_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>, …, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>), where each observation is a d-dimensional real vector, k-means clustering aims to partition the n observations into <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.63597em;\"></span><span class=\"strut bottom\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mrel\">≤</span><span class=\"mord mathit\">n</span></span></span></span>) sets <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> = {<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.05764em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.05764em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>, …, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.05764em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>} so as to minimize the within-cluster sum of squares (WCSS) (i.e. variance). Formally, the objective is to find:</p>\n<!--Mathematical equation in markdown take from wikipedia-->\n<!--Office work-->\n<!--Write about k-means-->\n<!--Determing k automatically-->\n<p>In Kmeans <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span> or the number of clusters can be taken as a hyperparameter. In order to determine <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span> automatically, either we can perform cross-validation or we can use other algorithms like silhouette analysis. Silhouette refers to a method of interpretation and validation of consistency within clusters of data.</p>\n<p>The silhouette value is a measure of how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The silhouette ranges from -1 to 1, where a high value indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters. If most objects have a high value, then the clustering configuration is appropriate. If many points have a low or negative value, then the clustering configuration may have too many or too few clusters.</p>\n<h2>Features in consideration, implementation and EDA involved</h2>\n<p>To construct fare calendar system as a Kmeans problem, we constructed features such as fare and date of journey for every arrival station, departure station and date of search(Since dynamic pricing of airline varies on these parameters heavily). We then dynamically constructed clusters for these fares. Using the above trained model we then, predicted every fare for different date of journey. This helps our fare calendar to give a better understanding of fare displayed (low, medium or high) for the searched route.</p>\n<!--Add some EDA and clustered prices with seperate bandwidth and use matplotlib-->\n<!--Scala job and Mlib usage-->\n<p>Data that needs to be taken into consideration is massive, moreover the algorithm should be run daily so that we can avoid stale clusters. We can write a spark job using <a href=\"https://spark.apache.org/docs/1.2.0/mllib-clustering.html\">MLib library</a>.</p>\n",
  "attributes": {
    "tags": [
      {
        "id": "project",
        "name": "project"
      }
    ],
    "title": "Smart Fare calendar system",
    "date": "2018-11-27T03:41:56.801Z",
    "updated_at": "2018-11-27T03:41:56.801Z",
    "description": "Design a simple fare calendar system in order to cluster different price range in respective air route to get a better understanding to price variation throughout the year. Instead of having just minimum, maximum and median airfare to represent three classes of fare distribution in fare calendar,\nwe can design a smart airfare categorization using clustering algorithms.",
    "collection": {
      "id": "airfare-insights",
      "name": "Airfare Insights"
    }
  },
  "title": "Smart Fare calendar system",
  "description": "Design a simple fare calendar system in order to cluster different price range in respective air route to get a better understanding to price variation throughout the year. Instead of having just minimum, maximum and median airfare to represent three classes of fare distribution in fare calendar,\nwe can design a smart airfare categorization using clustering algorithms.",
  "keywords": [
    "project"
  ],
  "published_at": "2018-11-27T03:41:56.801Z",
  "updated_at": "2018-11-27T03:41:56.801Z",
  "year": 2018,
  "month": 11,
  "day": 28,
  "next": {
    "id": "fare-alert-system",
    "slug": "fare-alert-system",
    "collection": "airfare-insights",
    "title": "Fare alert system",
    "description": "Purchasing a flight ticket, though a simple and quick affair, causes lot of anxiety to many travellers even today due to the fact that airlines frequently change fares. Due to this dynamic nature of airfare fluctuation, fare alert system plays a key role in customer engagement and better user experience in travel industry.",
    "published_at": "2017-05-12T00:00:00.000Z"
  },
  "prev": {
    "id": "coccinelle-usages",
    "slug": "coccinelle-usages",
    "collection": null,
    "title": "Coccinelle",
    "description": "Coccinelle is a program matching tool which allows programmers to easily write some complex style-preserving source-to-source transformations on C source code, for instance, code refactoring.\nThere are useful online resources which document this tool very well, however it is slightly difficult for a beginner to understand these concepts through these materials. So this is my attempt to explain the details of this tool in more convenient way.",
    "published_at": "2016-08-11T00:00:00.000Z"
  }
}