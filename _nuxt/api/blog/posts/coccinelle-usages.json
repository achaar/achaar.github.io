{
  "id": "coccinelle-usages",
  "slug": "coccinelle-usages",
  "highlightedLanguages": [
    "patch"
  ],
  "source": "---\ndate: 2016-08-11\n---\n# Coccinelle\n\nCoccinelle is a program matching tool which allows programmers to easily write some complex style-preserving source-to-source transformations on C source code, for instance, code refactoring.\nThere are useful online resources which document this tool very well, however it is slightly difficult for a beginner to understand these concepts through these materials. So this is my attempt to explain the details of this tool in more convenient way.\n\n## About Coccinelle\n\nCoccinelle is a program matching and transformation engine for C code. It works by providing a language SmPL (semantic patch language) for specifying desired matches and transformations in C code. initially, Coccinelle was initially targeted towards performing collateral evolutions in Linux, but it can be applied on any other C code.\n\n### Goals of Coccinelle\n\n* Automatically find code containing bugs or requiring collateral evolution.\n\n* Automatically fix bugs and perform collateral evolution.\n\n* Provide a system that is accessible to software developers.\n\n### Getting started with coccinelle\n\nIt is always helpful to learn via examples. So I will try to cover a set of examples which will help to understand every element of coccinelle tools in a very applied way. So to get started with coccinelle, let us work out with the following steps:\n\n* Step 1: Download coccinelle and install it. The Coccinelle binary is called spatch. For linux, you can do it via following command:\n\nsudo apt-get install coccinelle\n\n* Step-2: As we have discussed coccinelle utilizes semantic patch language. Lets consider a problem where we want to add parantheses over statement like !E & C so that it would become !(E & C). To solve this type of issue, make a file say ex1.cocci which contains:\n\n``` patch\n@@\nexpression E;\nconstant C;\n@@\n- !E & C\n+ !(E & C)\n```\n\n* Step -3 : Save the above code, then work out with following commands in your working directory.\n\n$ spatch --sp-file ex1.cocci --no-includes --dir {your directory path}/drivers/staging > ret.out.\n\nDid you find any satisfactory result? if yes, then submit some of the patches. Some of my accepted patches in linux foundation are [here](https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git/log/?h=staging-next&qt=author&q=somyaanand214%40gmail.com&showmsg=1)\n",
  "rendered": "<h1>Coccinelle</h1>\n<p>Coccinelle is a program matching tool which allows programmers to easily write some complex style-preserving source-to-source transformations on C source code, for instance, code refactoring.<br>\nThere are useful online resources which document this tool very well, however it is slightly difficult for a beginner to understand these concepts through these materials. So this is my attempt to explain the details of this tool in more convenient way.</p>\n<h2>About Coccinelle</h2>\n<p>Coccinelle is a program matching and transformation engine for C code. It works by providing a language SmPL (semantic patch language) for specifying desired matches and transformations in C code. initially, Coccinelle was initially targeted towards performing collateral evolutions in Linux, but it can be applied on any other C code.</p>\n<h3>Goals of Coccinelle</h3>\n<ul>\n<li>\n<p>Automatically find code containing bugs or requiring collateral evolution.</p>\n</li>\n<li>\n<p>Automatically fix bugs and perform collateral evolution.</p>\n</li>\n<li>\n<p>Provide a system that is accessible to software developers.</p>\n</li>\n</ul>\n<h3>Getting started with coccinelle</h3>\n<p>It is always helpful to learn via examples. So I will try to cover a set of examples which will help to understand every element of coccinelle tools in a very applied way. So to get started with coccinelle, let us work out with the following steps:</p>\n<ul>\n<li>Step 1: Download coccinelle and install it. The Coccinelle binary is called spatch. For linux, you can do it via following command:</li>\n</ul>\n<p>sudo apt-get install coccinelle</p>\n<ul>\n<li>Step-2: As we have discussed coccinelle utilizes semantic patch language. Lets consider a problem where we want to add parantheses over statement like !E &amp; C so that it would become !(E &amp; C). To solve this type of issue, make a file say ex1.cocci which contains:</li>\n</ul>\n<pre><code class=\"language-patch\">@@\nexpression E;\nconstant C;\n@@\n- !E &amp; C\n+ !(E &amp; C)\n</code></pre>\n<ul>\n<li>Step -3 : Save the above code, then work out with following commands in your working directory.</li>\n</ul>\n<p>$ spatch --sp-file ex1.cocci --no-includes --dir {your directory path}/drivers/staging &gt; ret.out.</p>\n<p>Did you find any satisfactory result? if yes, then submit some of the patches. Some of my accepted patches in linux foundation are <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git/log/?h=staging-next&amp;qt=author&amp;q=somyaanand214%40gmail.com&amp;showmsg=1\">here</a></p>\n",
  "attributes": {
    "date": "2016-08-11T00:00:00.000Z",
    "title": "Coccinelle",
    "updated_at": "2018-11-27T03:41:56.802Z",
    "description": "Coccinelle is a program matching tool which allows programmers to easily write some complex style-preserving source-to-source transformations on C source code, for instance, code refactoring.\nThere are useful online resources which document this tool very well, however it is slightly difficult for a beginner to understand these concepts through these materials. So this is my attempt to explain the details of this tool in more convenient way.",
    "tags": []
  },
  "title": "Coccinelle",
  "description": "Coccinelle is a program matching tool which allows programmers to easily write some complex style-preserving source-to-source transformations on C source code, for instance, code refactoring.\nThere are useful online resources which document this tool very well, however it is slightly difficult for a beginner to understand these concepts through these materials. So this is my attempt to explain the details of this tool in more convenient way.",
  "keywords": [],
  "published_at": "2016-08-11T00:00:00.000Z",
  "updated_at": "2018-11-27T03:41:56.802Z",
  "year": 2016,
  "month": 8,
  "day": 12,
  "next": {
    "id": "fare-calendar-system",
    "slug": "fare-calendar-system",
    "collection": "airfare-insights",
    "title": "Smart Fare calendar system",
    "description": "Design a simple fare calendar system in order to cluster different price range in respective air route to get a better understanding to price variation throughout the year. Instead of having just minimum, maximum and median airfare to represent three classes of fare distribution in fare calendar,\nwe can design a smart airfare categorization using clustering algorithms.",
    "published_at": "2018-11-27T03:41:56.801Z"
  },
  "prev": {
    "id": "building-datastore-hive",
    "slug": "building-datastore-hive",
    "collection": null,
    "title": "Datastore",
    "description": "Efficient way to construct hive datastore.",
    "published_at": "2018-11-27T03:41:56.801Z"
  }
}