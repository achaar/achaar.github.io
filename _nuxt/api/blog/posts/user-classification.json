{
  "id": "user-classification",
  "slug": "user-classification",
  "highlightedLanguages": [],
  "source": "---\ndate: 2017-03-11\ntags:\n  - project\n---\n# User classification\n\n## Problem statement\n\nBased on the activities performed by the user in travel marketplace, we aim to classify them with certain probability that how likely is the user to book a ticket.\n\n## Dataset preparation\n\nIn general, inorder to take every activity of a user into account, our dataset will contain both categorical as well as numerical data. In statistics, a categorical variable is a variable that can take on one of a limited, and usually fixed, number of possible values, assigning each individual or other unit of observation to a particular group or nominal category on the basis of some qualitative property. We have to preprocess our data in such a way that it will be able to deal with both categorical and numeric data.\n\n### Dealing with categorical data\n\nWe need to convert categorical variables into numerical data as we can not train our model using categorical variables and at the same time we can not lose on categorical values. In order to achieve this we can do [one-hot encoding](https://www.quora.com/What-is-one-hot-encoding-and-when-is-it-used-in-data-science). This method is quite popular as it performs really well for several machine learning algorithms.\n\n### Dealing with missing values\n\nIn general, nature of this dataset is very sparse, and often suffers from missing data issue. In order to resolve this, we can use following methods:\n\n* Ignore the tuple with missing value, but if a lot of tuple has missing data, this method can lead to a great data loss.\n\n* Use a global constant at missing values which can be the most frequent value.\n\n* Use the most probable value to fill in the missing value, this technique is the most popular one.\n\n### Dividing data into training, testing and validation dataset\n\nTo split dataset into training, testing and validation, the major concern is the amount of data and number of features contained it.\n\nThere are two competing concerns: with less training data, your parameter estimates have greater variance. With less testing data, your performance statistic will have greater variance. Broadly speaking you should be concerned with dividing data such that neither variance is too high, which is more to do with the absolute number of instances in each category rather than the percentage.\n\nIf you have a total of 100 instances, you're probably stuck with cross validation as no single split is going to give you satisfactory variance in your estimates. If you have 100,000 instances, it doesn't really matter whether you choose an 80:20 split or a 90:10 split (indeed you may choose to use less training data if your method is particularly computationally intensive).\n\nAssuming you have enough data to do proper held-out test data (rather than cross-validation), the following is an instructive way to get a handle on variances:\n\nSplit your data into training and testing (80/20 is indeed a good starting point)\nSplit the training data into training and validation (again, 80/20 is a fair split).\nSubsample random selections of your training data, train the classifier with this, and record the performance on the validation set\nTry a series of runs with different amounts of training data: randomly sample 20% of it, say, 10 times and observe performance on the validation data, then do the same with 40%, 60%, 80%. You should see both greater performance with more data, but also lower variance across the different random samples\nTo get a handle on variance due to the size of test data, perform the same procedure in reverse. Train on all of your training data, then randomly sample a percentage of your validation data a number of times, and observe performance. You should now find that the mean performance on small samples of your validation data is roughly the same as the performance.\n\nTo implement this we can use [sklearn.model_selection.train_test_split(*arrays, **options)](http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html#sklearn.model_selection.train_test_split). It basically split arrays or matrices into random train and test subsets. Then we can split training dataset further into validation and training set. Now, if we want to use K-fold cross validation, then we divide training dataset into K equal parts, and randomly train on K-1 dataset and validate on the remaining dataset.\n\n## Data preprocessing\n\nFor implementation of machine learning algorithms, it is advisable to apply following methods:\n\n* Standardization: The result of standardization (or Z-score normalization) is that the features will be rescaled so that they’ll have the properties of a standard normal distribution with μ=0 and σ=1 where μ is the mean (average) and σ is the standard deviation from the mean; standard scores (also called z scores) of the samples are calculated as follows:\n\nz = (x−μ)/σ\nStandardizing the features so that they are centered around 0 with a standard deviation of 1 is not only important if we are comparing measurements that have different units, but it is also a general requirement for many machine learning algorithms such as SVM and gradient descent.\n\n* Min-max scaling: An alternative approach to Z-score normalization (or standardization) is the so-called Min-Max scaling (often also simply called “normalization” - a common cause for ambiguities). In this approach, the data is scaled to a fixed range - usually 0 to 1. The cost of having this bounded range - in contrast to standardization - is that we will end up with smaller standard deviations, which can suppress the effect of outliers.\n\nA Min-Max scaling is typically done via the following equation:\n\nXnorm = (X−Xmin)/(Xmax−Xmin)\n\n## Algorithm used for training\n\nIn order to achieve feature scaling and estimation, we can use [scikit pipelines](http://scikit-learn.org/stable/modules/pipeline.html). Pipeline can be used to chain multiple estimators into one. This is useful as there is often a fixed sequence of steps in processing the data, for example feature selection, normalization and classification. Pipeline serves two purposes here:\nConvenience: You only have to call fit and predict once on your data to fit a whole sequence of estimators.\nJoint parameter selection: You can grid search over parameters of all estimators in the pipeline at once.\nAll estimators in a pipeline, except the last one, must be transformers (i.e. must have a transform method). The last estimator may be any type (transformer, classifier, etc.).\n\nFollowing are the algorithms that can be considered for classification:\n\n### Support vector machines\n\nsupport vector machines are supervised learning models with associated learning algorithms that analyze data used for classification and regression analysis. Given a set of training examples, each marked as belonging to one or the other of two categories, an SVM training algorithm builds a model that assigns new examples to one category or the other, making it a non-probabilistic binary linear classifier.\n\nThe advantages of support vector machines are:\n\n* Effective in high dimensional spaces. Still effective in cases where number of dimensions is greater than the number of samples.\n\n* It Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.\n\n* Versatile: different Kernel functions can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.\n\nThe disadvantages of support vector machines include:\n\n* If the number of features is much greater than the number of samples, the method is likely to give poor performances.\n\n* SVMs do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation (see Scores and probabilities, below).\n\nSince, we want a probability with which we can understand how likely user will book a ticket, so it becomes an expensive affair.\n\n### Logistic regression\n\n Logistic regression is the classical algorithm mainly utilised for binary classification. The binary logistic model is used to estimate the probability of a binary response based on one or more predictor (or independent) variables (features). It allows one to say that the presence of a risk factor increases the probability of a given outcome by a specific percentage.\n\n Due to this, we can consider this algorithm to solve our problem statement.\n\n Generally, to avoid overfitting, we implement logistic regression with L1 or L2 regularization. While implementing so, value of C becomes an hyperparameter. To estimate this hyperparameter, we can again use [scikit library](http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegressionCV.html).\n\n### Random forest\n\n[Random forests](https://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm) are an ensemble learning method for classification, regression and other tasks. They operate by generating multiple decision trees from\nthe training data and predict the class which is most popular among classes\npredicted by each tree.\n\nFeatures of Random Forests:\n\n* It is unexcelled in accuracy among current algorithms.\n\n* It runs efficiently on large data bases.\n\n* It can handle thousands of input variables without variable deletion.\n\n* It gives estimates of what variables are important in the classification.\n\n* It generates an internal unbiased estimate of the generalization error as the forest building progresses.\n\nHyperparameters in this algorithm is number of trees in the random forest. Moreover since, when the training set for the current tree is drawn by sampling with replacement, about one-third of the cases are left out of the sample. This oob (out-of-bag) data is used to get a running unbiased estimate of the classification error as trees are added to the forest. It is also used to get estimates of variable importance. So, there is no need to use cross validation.\n\n## Accuracy\n\n To check the accuracy of our model, accuracy calculation is not enough. This is because we have sparse data, so the number of positive casesis very less, thus even a high accuracy can result in poor estimation. We then considered:\n\n* Precision: precision (also called positive predictive value) is the fraction of relevant instances among the retrieved instances.\n\n* Recall: recall (also known as sensitivity) is the fraction of relevant instances that have been retrieved over total relevant instances in the image.\n\n* F-score: F-score (F1 score) is the harmonic mean of precision and recall \n\n## Model selection techniques\n\nCross validation can be utilised for model selection process.\n\n### Cross validation\n\nk-fold cross validation or cross validation, that holds out less data each time can be implemented as follows:\n\n* Randomly split S into k disjoint subsets of m/k training examples each. Let’s call these subsets $S_1$, . . . , $S_k$.\n\n* For each model Mi, we evaluate it as follows: For j = 1, . . . , k Train the model Mi on S1 ∪···∪Sj−1 ∪Sj+1 ∪···Sk (i.e., train on all the data except Sj) to get some hypothesis hij.\n\n* Test the hypothesis hij on Sj , to get εˆSj (hij ). The estimated generalization error of model Mi is then calculated as the average of the εˆSj (hij)’s (averaged over j).\n\n* Pick the model Mi with the lowest estimated generalization error, and retrain that model on the entire training set S. The resulting hypothesis is then output as our final answer.\n\nTypically a value of k can be 10. K-fold validation prevents wastage of data as well.\n\nWhile k = 10 is a commonly used choice, in problems in which data is really scarce, sometimes we will use the extreme choice of k = m in order to leave out as little data as possible each time. In this setting, we would repeatedly train on all but one of the training examples in S, and test on that held-out example. The resulting m = k errors are then averaged together to obtain our estimate of the generalization error of a model. This method has its own name; since we’re holding out one training example at a time, this method is called leave-one-out cross validation.\n\n## Further possibilities\n\nWe can also explore other algorithms such as:\n\n* Exploring neural networks\n\n* Since activities of a user is dynamic in nature, it will be intersting to Model it as reinforcement learning problem which takes previous calculated probability of booking a ticket as a feature for further learning.",
  "rendered": "<h1>User classification</h1>\n<h2>Problem statement</h2>\n<p>Based on the activities performed by the user in travel marketplace, we aim to classify them with certain probability that how likely is the user to book a ticket.</p>\n<h2>Dataset preparation</h2>\n<p>In general, inorder to take every activity of a user into account, our dataset will contain both categorical as well as numerical data. In statistics, a categorical variable is a variable that can take on one of a limited, and usually fixed, number of possible values, assigning each individual or other unit of observation to a particular group or nominal category on the basis of some qualitative property. We have to preprocess our data in such a way that it will be able to deal with both categorical and numeric data.</p>\n<h3>Dealing with categorical data</h3>\n<p>We need to convert categorical variables into numerical data as we can not train our model using categorical variables and at the same time we can not lose on categorical values. In order to achieve this we can do <a href=\"https://www.quora.com/What-is-one-hot-encoding-and-when-is-it-used-in-data-science\">one-hot encoding</a>. This method is quite popular as it performs really well for several machine learning algorithms.</p>\n<h3>Dealing with missing values</h3>\n<p>In general, nature of this dataset is very sparse, and often suffers from missing data issue. In order to resolve this, we can use following methods:</p>\n<ul>\n<li>\n<p>Ignore the tuple with missing value, but if a lot of tuple has missing data, this method can lead to a great data loss.</p>\n</li>\n<li>\n<p>Use a global constant at missing values which can be the most frequent value.</p>\n</li>\n<li>\n<p>Use the most probable value to fill in the missing value, this technique is the most popular one.</p>\n</li>\n</ul>\n<h3>Dividing data into training, testing and validation dataset</h3>\n<p>To split dataset into training, testing and validation, the major concern is the amount of data and number of features contained it.</p>\n<p>There are two competing concerns: with less training data, your parameter estimates have greater variance. With less testing data, your performance statistic will have greater variance. Broadly speaking you should be concerned with dividing data such that neither variance is too high, which is more to do with the absolute number of instances in each category rather than the percentage.</p>\n<p>If you have a total of 100 instances, you're probably stuck with cross validation as no single split is going to give you satisfactory variance in your estimates. If you have 100,000 instances, it doesn't really matter whether you choose an 80:20 split or a 90:10 split (indeed you may choose to use less training data if your method is particularly computationally intensive).</p>\n<p>Assuming you have enough data to do proper held-out test data (rather than cross-validation), the following is an instructive way to get a handle on variances:</p>\n<p>Split your data into training and testing (80/20 is indeed a good starting point)<br>\nSplit the training data into training and validation (again, 80/20 is a fair split).<br>\nSubsample random selections of your training data, train the classifier with this, and record the performance on the validation set<br>\nTry a series of runs with different amounts of training data: randomly sample 20% of it, say, 10 times and observe performance on the validation data, then do the same with 40%, 60%, 80%. You should see both greater performance with more data, but also lower variance across the different random samples<br>\nTo get a handle on variance due to the size of test data, perform the same procedure in reverse. Train on all of your training data, then randomly sample a percentage of your validation data a number of times, and observe performance. You should now find that the mean performance on small samples of your validation data is roughly the same as the performance.</p>\n<p>To implement this we can use <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html#sklearn.model_selection.train_test_split\">sklearn.model_selection.train_test_split(*arrays, **options)</a>. It basically split arrays or matrices into random train and test subsets. Then we can split training dataset further into validation and training set. Now, if we want to use K-fold cross validation, then we divide training dataset into K equal parts, and randomly train on K-1 dataset and validate on the remaining dataset.</p>\n<h2>Data preprocessing</h2>\n<p>For implementation of machine learning algorithms, it is advisable to apply following methods:</p>\n<ul>\n<li>Standardization: The result of standardization (or Z-score normalization) is that the features will be rescaled so that they’ll have the properties of a standard normal distribution with μ=0 and σ=1 where μ is the mean (average) and σ is the standard deviation from the mean; standard scores (also called z scores) of the samples are calculated as follows:</li>\n</ul>\n<p>z = (x−μ)/σ<br>\nStandardizing the features so that they are centered around 0 with a standard deviation of 1 is not only important if we are comparing measurements that have different units, but it is also a general requirement for many machine learning algorithms such as SVM and gradient descent.</p>\n<ul>\n<li>Min-max scaling: An alternative approach to Z-score normalization (or standardization) is the so-called Min-Max scaling (often also simply called “normalization” - a common cause for ambiguities). In this approach, the data is scaled to a fixed range - usually 0 to 1. The cost of having this bounded range - in contrast to standardization - is that we will end up with smaller standard deviations, which can suppress the effect of outliers.</li>\n</ul>\n<p>A Min-Max scaling is typically done via the following equation:</p>\n<p>Xnorm = (X−Xmin)/(Xmax−Xmin)</p>\n<h2>Algorithm used for training</h2>\n<p>In order to achieve feature scaling and estimation, we can use <a href=\"http://scikit-learn.org/stable/modules/pipeline.html\">scikit pipelines</a>. Pipeline can be used to chain multiple estimators into one. This is useful as there is often a fixed sequence of steps in processing the data, for example feature selection, normalization and classification. Pipeline serves two purposes here:<br>\nConvenience: You only have to call fit and predict once on your data to fit a whole sequence of estimators.<br>\nJoint parameter selection: You can grid search over parameters of all estimators in the pipeline at once.<br>\nAll estimators in a pipeline, except the last one, must be transformers (i.e. must have a transform method). The last estimator may be any type (transformer, classifier, etc.).</p>\n<p>Following are the algorithms that can be considered for classification:</p>\n<h3>Support vector machines</h3>\n<p>support vector machines are supervised learning models with associated learning algorithms that analyze data used for classification and regression analysis. Given a set of training examples, each marked as belonging to one or the other of two categories, an SVM training algorithm builds a model that assigns new examples to one category or the other, making it a non-probabilistic binary linear classifier.</p>\n<p>The advantages of support vector machines are:</p>\n<ul>\n<li>\n<p>Effective in high dimensional spaces. Still effective in cases where number of dimensions is greater than the number of samples.</p>\n</li>\n<li>\n<p>It Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.</p>\n</li>\n<li>\n<p>Versatile: different Kernel functions can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.</p>\n</li>\n</ul>\n<p>The disadvantages of support vector machines include:</p>\n<ul>\n<li>\n<p>If the number of features is much greater than the number of samples, the method is likely to give poor performances.</p>\n</li>\n<li>\n<p>SVMs do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation (see Scores and probabilities, below).</p>\n</li>\n</ul>\n<p>Since, we want a probability with which we can understand how likely user will book a ticket, so it becomes an expensive affair.</p>\n<h3>Logistic regression</h3>\n<p>Logistic regression is the classical algorithm mainly utilised for binary classification. The binary logistic model is used to estimate the probability of a binary response based on one or more predictor (or independent) variables (features). It allows one to say that the presence of a risk factor increases the probability of a given outcome by a specific percentage.</p>\n<p>Due to this, we can consider this algorithm to solve our problem statement.</p>\n<p>Generally, to avoid overfitting, we implement logistic regression with L1 or L2 regularization. While implementing so, value of C becomes an hyperparameter. To estimate this hyperparameter, we can again use <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegressionCV.html\">scikit library</a>.</p>\n<h3>Random forest</h3>\n<p><a href=\"https://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm\">Random forests</a> are an ensemble learning method for classification, regression and other tasks. They operate by generating multiple decision trees from<br>\nthe training data and predict the class which is most popular among classes<br>\npredicted by each tree.</p>\n<p>Features of Random Forests:</p>\n<ul>\n<li>\n<p>It is unexcelled in accuracy among current algorithms.</p>\n</li>\n<li>\n<p>It runs efficiently on large data bases.</p>\n</li>\n<li>\n<p>It can handle thousands of input variables without variable deletion.</p>\n</li>\n<li>\n<p>It gives estimates of what variables are important in the classification.</p>\n</li>\n<li>\n<p>It generates an internal unbiased estimate of the generalization error as the forest building progresses.</p>\n</li>\n</ul>\n<p>Hyperparameters in this algorithm is number of trees in the random forest. Moreover since, when the training set for the current tree is drawn by sampling with replacement, about one-third of the cases are left out of the sample. This oob (out-of-bag) data is used to get a running unbiased estimate of the classification error as trees are added to the forest. It is also used to get estimates of variable importance. So, there is no need to use cross validation.</p>\n<h2>Accuracy</h2>\n<p>To check the accuracy of our model, accuracy calculation is not enough. This is because we have sparse data, so the number of positive casesis very less, thus even a high accuracy can result in poor estimation. We then considered:</p>\n<ul>\n<li>\n<p>Precision: precision (also called positive predictive value) is the fraction of relevant instances among the retrieved instances.</p>\n</li>\n<li>\n<p>Recall: recall (also known as sensitivity) is the fraction of relevant instances that have been retrieved over total relevant instances in the image.</p>\n</li>\n<li>\n<p>F-score: F-score (F1 score) is the harmonic mean of precision and recall</p>\n</li>\n</ul>\n<h2>Model selection techniques</h2>\n<p>Cross validation can be utilised for model selection process.</p>\n<h3>Cross validation</h3>\n<p>k-fold cross validation or cross validation, that holds out less data each time can be implemented as follows:</p>\n<ul>\n<li>\n<p>Randomly split S into k disjoint subsets of m/k training examples each. Let’s call these subsets <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.05764em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>, . . . , <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.05764em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>.</p>\n</li>\n<li>\n<p>For each model Mi, we evaluate it as follows: For j = 1, . . . , k Train the model Mi on S1 ∪···∪Sj−1 ∪Sj+1 ∪···Sk (i.e., train on all the data except Sj) to get some hypothesis hij.</p>\n</li>\n<li>\n<p>Test the hypothesis hij on Sj , to get εˆSj (hij ). The estimated generalization error of model Mi is then calculated as the average of the εˆSj (hij)’s (averaged over j).</p>\n</li>\n<li>\n<p>Pick the model Mi with the lowest estimated generalization error, and retrain that model on the entire training set S. The resulting hypothesis is then output as our final answer.</p>\n</li>\n</ul>\n<p>Typically a value of k can be 10. K-fold validation prevents wastage of data as well.</p>\n<p>While k = 10 is a commonly used choice, in problems in which data is really scarce, sometimes we will use the extreme choice of k = m in order to leave out as little data as possible each time. In this setting, we would repeatedly train on all but one of the training examples in S, and test on that held-out example. The resulting m = k errors are then averaged together to obtain our estimate of the generalization error of a model. This method has its own name; since we’re holding out one training example at a time, this method is called leave-one-out cross validation.</p>\n<h2>Further possibilities</h2>\n<p>We can also explore other algorithms such as:</p>\n<ul>\n<li>\n<p>Exploring neural networks</p>\n</li>\n<li>\n<p>Since activities of a user is dynamic in nature, it will be intersting to Model it as reinforcement learning problem which takes previous calculated probability of booking a ticket as a feature for further learning.</p>\n</li>\n</ul>\n",
  "attributes": {
    "date": "2017-03-11T00:00:00.000Z",
    "tags": [
      {
        "id": "project",
        "name": "project"
      }
    ],
    "title": "User classification",
    "updated_at": "2018-11-27T03:41:56.802Z",
    "description": "Based on the activities performed by the user in travel marketplace, we aim to classify them with certain probability that how likely is the user to book a ticket.",
    "collection": {
      "id": "machine-learning",
      "name": "Machine Learning"
    }
  },
  "title": "User classification",
  "description": "Based on the activities performed by the user in travel marketplace, we aim to classify them with certain probability that how likely is the user to book a ticket.",
  "keywords": [
    "project"
  ],
  "published_at": "2017-03-11T00:00:00.000Z",
  "updated_at": "2018-11-27T03:41:56.802Z",
  "year": 2017,
  "month": 3,
  "day": 12,
  "next": {
    "id": "supervised-nuclei-segmentation",
    "slug": "supervised-nuclei-segmentation",
    "collection": "machine-learning",
    "title": "Supervised approach for nuclei segmentation",
    "description": "Segmentation is an important stage in almost every problem involving digital image analysis. In image segmentation we aim to partition the spatial domain of the image, thereby delimiting the region of interest which correspond to the target objects in the concerned image analysis.",
    "photo": "/images/nuclei-segmentation/training.jpg",
    "published_at": "2017-08-11T00:00:00.000Z"
  }
}